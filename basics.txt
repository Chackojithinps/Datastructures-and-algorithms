Basic
----------------------------

1Algorithms

   -->Algorithms means Step by step instructions.

2.Complexity Analysis.

   --> this means analyzing a solution.How much time and space will take to execute a program.

3.the memmory when an application runs will store in RAM.

4.In computer everything is representes as 0 1 0 1 (binary form)

5.8 bits is one Byte. (0->one bit 1 ->one bit like this 8 bits together is one byte).

6.to store an integer 4 bytes is needed.that means 32 bits.

7.Array needs continuous positions in memmory.(Continuous memmory Allocation)

8.non-contigious-memmory-allocation- it will not store continuous.one byte will be in one place and 
  another will be in another place. like that (exmaple linkiedlist)

.9 Algorithm to find 1 - n numbers.

    .tep 1: START

    Step 2: 
      - Set n = 10

    Step 3: 
      - Initialize a loop variable i with an initial value of 1

    Step 4: 
      - Check if i <= n (1 <= 10) - condition is true, continue to Step 5

    Step 5: 
      - Print the value of i using console.log(i)

    Step 6: 
      - Increment i by 1 (i++)

    Step 7: 
      - Repeat Steps 4-6 until the condition i <= n becomes false

    Step 8: END

-------------------------------
Big -o -Notation
-------------------------------


1.Here actually it means the growth rate according to the input coming.

Time complexity----------->

2.linear time complexity ->o(n)
  
  eg:fucntin arr[]             
      for(int i=0;i<n;i++){     O(n)
        sum=sum+arr[i]          o(1)
      }  
      return sum;               o(1)
      Time complexity = O(1)+O(n)*O(1)+O(1)
       Here only consider the largest One . that means O(n).as per input only O(n) will changes.with O(1) we cant calculate 
       growth.                          
     
3.constant time complexity ->o(1)
   eg:functin(arr){
       int k=arr[0]    O(1)
       return k;       O(1)
   }
   Here time complexity is O(1)+O(1) =O(2) .but O(2) will consider as O(1).because there wil be no growth rate according to 
   input.
   
4.quadratic time complexity ->o(n)^2
    eg:fucntin (arr1,arr2){
        for(int i=0;i<n;i++){        O(n)
            for(int j=0;j<n;j++){    O(n)
                k=arr[j]+arr[i]      O(1)
            }
        }     
        return k;                    O(1)
    }
    here TC is O(n)*O(n)*O(1)+O(1) =O(n)^2; here constants wil neglet.

space Complexity --------->

  functin(arr){
    for(int i =0;i<n;i++){
        temp=arr[i];
    }
  }
    here the space complexity is O(1) .here in temp the values is replaces by another number.
    (in the same space the value is replacing)
    so it wont take another space .
    but if we put these  values in another array it will be O(n) space complexity.
    beacuase it will take new spaces for it for each time.
    

    .when we are initializating an array its space and time complexity will be O(n).

2. int[] arr= new int[10]
    Here the space complexity is O(n).because it will take 10 spaces in memmory.
    here in this case of arry initialization time complexity also O(n). 
    to take and allocate memory it takes O(n).(system automatically do)

Dynamic array------>

  .we dont want to make size of array when it is declaring.automatically it will change size according to the input.
  .in js and python already the is dynamic.
  .but laguages like java and c have static array.by using Arryalist java making array dynamically.
  .dynamic array means when create an array it will create double the size of array.
  .in dynamic arry time complexity is O(1)T and space complexity is O(1)S.(becasue there is no need to create.just apply the value).
  .But if that size also exceeds then it will create a new array double the size of newly creating array.
  .in this case the time complexity becomes O(n) (because we have to copy to new arrya) and space complexity also O(n).
   beacause it is creating extra spaces(for making the array double size)

----------------------------------------------   
linkiedlist
----------------------------------------------

.Array is backtoBack memmory space.
.in linkedlist memmoryspace is not contigious
.there is a value and a next variable for the adddress of next value.together these 
 two are called a node.
.in the case of set and get time complexity of a linekdlist is O(n) and space complexity is O(1).because it needs to traverse through
 all to get and set the values.
.in the case of traverse also it is O(n).
.which the elements are not stored at contiguous memory locations. The elements in a linked list are linked using pointers 


.Why Linked List? 

 .The size of the arrays is fixed
 .insertion of a new element / Deletion of a existing element in an array of elements is expensive:
  The room has to be created for the new elements and to create room existing elements have to be shifted but in Linked list if we have
  the head node then we can traverse to any node through it and insert new node at the required position.

.Advantages of Linked Lists over arrays:

    .Dynamic Array.

    .Ease of Insertion/Deletion.

    .Insertion at the beginning is a constant time operation and takes O(1) time, as compared to arrays where inserting
     an element at the beginning takes O(n) time,where n is the number of elements in the array.

    .Memory Efficiency: Linked lists utilize memory efficiently. Unlike arrays, linked lists do not require a contiguous block of memory
     to store elements. Each element in a linked list can be dynamically allocated, allowing for more efficient memory usage,
     especially when dealing with large or varying-sized data.

.Drawbacks of Linked Lists: 

    .Random access is not allowed. We have to access elements sequentially starting from the first node(head node).
    .Extra memory space for a pointer is required with each element of the list.  
    .Inefficient Search: Searching for a specific element in a linked list has a time complexity of O(n) since sequential traversal is required.

.Applications of Linked Lists
 
    .Linked lists are often used to implement other data structures such as stacks, queues, and hash tables.
     These data structures can be efficiently implemented using linked lists as they allow for easy insertion,
     deletion, and rearrangement of elements.

    .Dynamic Memory Allocation: Linked lists are useful for dynamic memory allocation, 

.Difference between array and linkedlist.
     
     Implementation:

        Array: An array is a contiguous block of memory where elements are stored sequentially. Elements in an array can be accessed
        directly using their indices.

        Linked List: A linked list consists of nodes where each node contains the data and a reference (or link) to the next node in
        the list. The nodes can be scattered across the memory, and they are connected through these references.
       
     Memory Management:

        Array: Arrays have a fixed size determined during their creation. If more elements need to be added beyond the array's capacity,
         a new array with a larger size must be created, and the existing elements must be copied to the new array.

        Linked List: Linked lists can grow or shrink dynamically as elements are added or removed. Each node in a linked list can be
         allocated and deallocated independently.
    
    Insertion and Deletion:

        Array: Insertion or deletion of elements within an array can be costly, especially in the middle or at the beginning, as it
         requires shifting subsequent elements. Adding or removing elements at the end of the array is generally more efficient.
        Linked List: Insertion or deletion of elements in a linked list can be done more efficiently, especially when performed at the
         beginning or in the middle. It involves changing the references of a few nodes without shifting the entire list.
    
    Random Access:

        Array: Arrays allow for constant-time random access to elements, as they can be accessed directly using their indices.
        Linked List: Linked lists do not support direct access to elements by index. To access an element in a linked list,
         you need to traverse the list from the beginning or end until you reach the desired position.


----------------------------------------------------------
Recursion
----------------------------------------------------------

. while the functin is not executing it will remains the stack.
. When a functin finishing executing it will remove from the stack.and the flow of program restored to where that function was called.
. A Recursion means a function that call iteself . 
. in order to stop the Recursion we have to providet the base condition.
. in Recursion since the same function is calling again and again ,the memmory is taking seperately.
. As many times you call the functin.it will take seperate space;
. SO if we dont give base condition stack will getting filled .so at one time memmory of computer get exceeds the limit(stack overflow error).

why recursion?
  . it helps us to solving bigger/complex problems in a simple way.
  . space complexity is O(n)
  . when you write a recursion in formula, then it is called reuccuracne relation.

  Types of recurrance relation
    .linear recurrance relation (finbonacci number(eg))
    .divide and conquer recurrance relation. (binary search (eg))

.what variables you need pass to future funciton call ,put inside the argumetns.
.what all variabels that no need to future calls,pass it inside the body of that function.
.Dynamic programming means if in the recursion calls two or more recursion calls are doing the same work dont compute it agian and again.
.whenever you are calling a recursion call,make sure you are returning if there is returning type.
